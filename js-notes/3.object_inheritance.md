### Prototypal Inheritance
Each object is derived from the class "Object" as you now.

For example lets say we created an array : 
```js
const arr = []
```
and if we look up the methods this array object have :
```js
arr.__proto__
```
we can see that there are a lot of methods :

![alt text](image-1.png)

and lets also create an object object and look up its proto as well : 
```js
const obj = new Object()
``` 
```js
obj.__proto__
```
it has some methods as well:
![alt text](image-2.png)


and as you may notice the function of .toString() is defied in both proto. So which one is actually get called if I invoke this method in arr object for example:
```js
arr.toString()
```

now it is an important rule : "the most specific method will be called"

therefore the method defined in array object itself is more specific than the method defined in object class. Therefore when we invoke .torString() method on the arr object, the one that defined in array class will be invoked.


### primitive types has wrappers

as you know primitive types doesnt have a function.
for example this will raise an error: 
```js
42.toString()
```
but if we do that :
```js
const num = 42
num.toString()
//"42"
```
so the reason of that is js actually wrap the primitive type with an wrapper class. when you look its proto you can see that prototype class is a class named "Number"
```js
num.__proto__
```
![alt text](image-3.png)

but this is not the actual class of num object here, it is protoptype class of num object. so if you do that, you can see that it is not the object of Number class: 
```js
x instanceof Number
//false
```

but for example you can change the .toString() function behavior by : 
```js
Number.prototype.toString = function() {
   return "100"
}
```

now you can see that you num.toString() will output "100". 咱
yea, this is the cons of inheritance, a wrong implementation will fuck up all your object you created loong time agoo maybe. So dont do this, it is only for educational purposes :)

---

In js, classes are just syntactic sugar for protoptypical inheritance.

Every object has a prototype. (means derived from a class)

inheritance bu protoptypelar sayesinde salan覺r.

繹rnein u kod : 
```js
class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks`);
    }
}

const dog = new Dog("myDog");
dog.speak(); // Dog barks
```
繹rnein bu kod sonras覺nda dog objesine bakarsak unu g繹r羹r羹z :

![alt text](image-8.png)

fakat ayn覺 kodu direk class keywordunu kullanmadan u ekilde de yazabiliriz :

```js
let Animal = {
name : null,
speak : function () {
        console.log(`${this.name} makes a sound`);
    }
};

let Dog = {
    __proto__ : Animal,
    name : "myDog"
}
```
![alt text](image-9.png)

Not : bu 繹rnekte Dog.bark() yap覺ld覺覺nda neden "myDog makes a sound" yazd覺覺n覺 
fakat "null makes a sound" yazd覺覺n覺 "this" class覺nda iledik. not: cevap "Property Resolution in the Prototype Chain"


hatta ayn覺 kodu object constructor kullanarak da yazabiliriz :

```js
let Animal = {
name : null,
speak : function () {
        console.log(`${this.name} makes a sound`);
    }
};


function Dog(name){
this.name = name;
this.__proto__ = Animal;
}
```
ard覺ndan bir obje oluturup speak fonksiyonunu invoke edebiliriz:

```
const myDog = new Dog("myDog");
myDog.speak();
> myDog makes a sound
```
![alt text](image-10.png)

---

yukarda g繹rd羹羹m羹z farkl覺 ekillerde obje oluturabiliriz ve bir ekilde inheritance 覺 kullanabiliriz.

peki bu 3 y繹ntemle ilgili shared method meselesine bakal覺m :

yukardaki 繹rneklerde speak fonksiyonu direk prototype da olduu i癟in zaten her 繹rnekte shared method olay覺 mevcuttu. yani yeni bir dog objesi oluturduumuzda ayn覺 speak fonkiyonu t羹m dog objelerinden ula覺labiliyordu. 

speak methodu direk oluturduumuz objede olsayd覺, bu methodun shared olup olmad覺覺 durumu nas覺l olacakt覺 : 

K覺sa 繹zet tablo u ekilde : 

| Type               | Prototype Accessor   | shared methods |
|--------------------|---------------------|------------------|
| Object Literal    | Object.prototype    | No              |
| Constructor Function | Constructor.prototype | No         |
| Class             | Class.prototype     | Yes             |


burdaki object literal dediimiz, hem bizim objeyi hem de parent class覺 obje olarak yazd覺覺m覺 繹rnek oluyor.

constuctor function ve class ise isminden belli olan dier 繹rnekler.

imdi baz覺 ufak cod snippetleriyle bunun ger癟ekten b繹yle olduunu g繹sterelelim : 


object literal olarak obje oluturduumuzda zaten shared method olmad覺覺 bariz ortada : 
```js
let Animal = {
   name : null,
   speak : function () {
         console.log(`${this.name} makes a sound`);
      }
};

let Dog = {
    __proto__ : Animal,
    name : "myDog"
    bark : function () {
        console.log(`${this.name} barked`);
    }
}

let Dog2 = {
    __proto__ : Animal,
    name : "myDog"
    bark : function () {
        console.log(`${this.name} barked`);
    }
}

console.log(Dog.bark === Dog2.bark)
> False
```


bu da constuctor function 繹rnei : ayn覺 constructor function ile yarat覺lmas覺na ramen ayn覺 fonksiyonlara bakm覺yorlar dog objeleri.

```js
function Dog(name) {
    this.name = name;
    this.bark = function() {
        console.log(this.name + " barked");
    };
}

const dog1 = new Dog("James");
const dog2 = new Dog("Max");

console.log(dog1.bark === dog2.bark); // false (different function instances)
```

fakat eer istersek constructor function kullanarak da shared method u direk Dog objesinin prototype覺na  explicity balayarak u ekilde ger癟ekletirebiliriz : 

```js
function Dog(name) {
    this.name = name;
}

// Define `bark` on the prototype (shared among instances)
Dog.prototype.bark = function() {
    console.log(this.name + " barked");
};

const dog1 = new Dog("James");
const dog2 = new Dog("Max");

console.log(dog1.bark === dog2.bark); // true (same function reference)
```

class kulland覺覺m覺zda ise classdaki t羹m propertyler ve methodlar direk prototype覺n i癟inde oluturulur, bu y羹zden shared method otomatik olarak mevcut olur. 

```js
class Dog {
    constructor(name) {
        this.name = name;
    }

    bark() {
        console.log(this.name + " barked");
    }
}

const dog1 = new Dog("James");
const dog2 = new Dog("Max");

console.log(dog1.bark === dog2.bark); // true (shared method)
```



